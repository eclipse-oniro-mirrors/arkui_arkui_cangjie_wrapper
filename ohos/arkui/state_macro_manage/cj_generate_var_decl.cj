/*
 * Copyright (c) 2025 Huawei Device Co., Ltd.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// The Cangjie API is in Beta. For details on its capabilities and limitations, please refer to the README file.

macro package ohos.arkui.state_macro_manage

import std.ast.*
import std.collection.*

/*
 * Record init function information which is generated by @Component or @Observed
 * first one is init param
 * second is assign expression in init body
 * third is the call of subscribe function in init body
 * like
 * let initInfo: MacroExpandInitInfo = getInitInfo()
 * let initParam = initInfo[0]
 * let initBodyAssign = initInfo[1]
 * let initBodySubscribe = initInfo[2]
 * quote(
 *     init($initParam) {
 *         $initBodyAssign
 *         $initBodySubscribe
 *     }
 * )
 */
type MacroExpandInitInfo = (Tokens, Tokens, Tokens)

func generateVarDecl(varDecl: VarDecl): MacroExpandInitInfo {
    let identifier = varDecl.identifier

    match (stateManageHandler.stateInformation.get(identifier.value)) {
        case None => generateCommonVarDecl(varDecl)
        case Some(v) => generateStateVarDecl(v[0], v[1], varDecl)
    }
}

extend VarDecl {
    func getTypeByInitializer(): Tokens {
        try {
            let v = this.declType
            return quote($v)
        } catch (e: Exception) {
            ()
        }

        let identifier = identifier.value
        let initValue = expr

        match (initValue) {
            case v: LitConstExpr => match (v.literal.kind) {
                case STRING_LITERAL => quote(String)
                case BOOL_LITERAL => quote(Bool)
                case FLOAT_LITERAL => quote(Float64)
                case INTEGER_LITERAL => quote(Int64)
                case CHAR_LITERAL => quote(Rune)
                case _ => throw IllegalArgumentException(
                    "The type of variable '${identifier}' cannot be derived from the initialization expression," +
                        "please specify its type explicitly.")
            }
            case _ => throw IllegalArgumentException(
                "The type of variable '${identifier}' cannot be derived from the initialization expression," +
                    "please specify its type explicitly.")
        }
    }
}

func generateCommonVarDecl(varDecl: VarDecl): MacroExpandInitInfo {
    // an initialized 'let' constant can not be assigned, so it will not be added to init function.
    let commonVarKeyword = varDecl.keyword
    let modifiers = varDecl.modifiers
    for (modifier in modifiers) {
        if (modifier.keyword.value == "static") {
            diagReport(DiagReportLevel.ERROR, Tokens().append(modifier),
                "Declaring static variable in custom component is not allowed.", "")
        }
    }
    var hasInitializer = false
    try {
        varDecl.expr
        hasInitializer = true
    } catch (e: Exception) {
        hasInitializer = false
    }
    if (commonVarKeyword.value == "let" && hasInitializer) {
        return (Tokens(), Tokens(), Tokens())
    }
    let commonVarDeclIdent = varDecl.identifier
    let commonVarDeclType = varDecl.getTypeByInitializer()

    let initBody = match (hasInitializer) {
        case true => quote(
                match ($commonVarDeclIdent) {
                    case Some(v) => this.$commonVarDeclIdent = v.get()
                    case _ => ()
                }
            )
        case _ => quote(
                this.$commonVarDeclIdent = $commonVarDeclIdent.get()
            )
    }

    let initParam = match (hasInitializer) {
        case true => quote($commonVarDeclIdent!: Option<$OBSERVED_PROPERTY<$commonVarDeclType>> = None)
        case _ => quote($commonVarDeclIdent!: $OBSERVED_PROPERTY<$commonVarDeclType>)
    }
    return (initParam, initBody, Tokens())
}

func generateStateVarDecl(kind: VariableKind, varDecl: VarDecl, varExpand: VarDecl): MacroExpandInitInfo {
    match (kind) {
        case StateTy => generateStateInit(varDecl, varExpand)
        case PropTy => generatePropInit(varDecl, varExpand)
        case LinkTy => generateLinkInit(varDecl, varExpand)
        case ProvideTy => generateProvideInit(varDecl, varExpand)
        case ConsumeTy => generateConsumeInit(varDecl, varExpand)
        case CommonTy => (Tokens(), Tokens(), Tokens())
        case AppStorageLinkTy => generateStorageInit(varDecl, varExpand, true)
        case AppStoragePropTy => generateStorageInit(varDecl, varExpand, false)
        case LocalStorageLinkTy => generateStorageInit(varDecl, varExpand, true)
        case LocalStoragePropTy => generateStorageInit(varDecl, varExpand, false)
        case LocalStorageLinkInterOpTy => generateStorageInit(varDecl, varExpand, true)
        case LocalStoragePropInterOpTy => generateStorageInit(varDecl, varExpand, false)
    }
}

func generateStorageInit(
    varDecl: VarDecl,
    varExpand: VarDecl,
    _: Bool
): MacroExpandInitInfo {
    let initValue = varDecl.expr
    let identifierAssociated = varExpand.identifier
    let initBodySubscribe = quote(
        this.$identifierAssociated.subscribeEx(this)
    )
    return (Tokens(), Tokens(), initBodySubscribe)
}

enum VarInitType {
    | StateType
    | PropType
}

func varInitAssign(identifier: Token, varExpand: VarDecl, initType: VarInitType): Tokens {
    let identifierAssociated = varExpand.identifier
    let valTypeExpand = varExpand.getTypeByInitializer()
    let info = mangle(identifier.value)
    var hasInitializer = false
    try {
        varExpand.expr
        hasInitializer = true
    } catch (e: Exception) {
        hasInitializer = false
    }
    if (!hasInitializer) {
        match (initType) {
            case StateType => return quote(
                    this.$identifierAssociated = $valTypeExpand($info, $identifier.get())
                )
            case PropType => return quote(
                    this.$identifierAssociated = $identifier.createProp($info)
                )
        }
    }
    match (initType) {
        case StateType => return quote(
                match ($identifier) {
                    case Some(v) => this.$identifierAssociated = $valTypeExpand($info, v.get())
                    case _ => ()
                }
            )
        case PropType => return quote(
                match ($identifier) {
                    case Some(v) => this.$identifierAssociated = v.createProp($info)
                    case _ => ()
                }
            )
    }
}

func generateStateInit(varDecl: VarDecl, varExpand: VarDecl): MacroExpandInitInfo {
    let initValue = varDecl.expr
    let identifier = varDecl.identifier
    let valType = varExpand.getTypeByInitializer()

    let identifierAssociated = varExpand.identifier
    let initParam = quote($identifier!: Option<$valType> = None)

    let initBodyAssign = varInitAssign(identifier, varExpand, VarInitType.StateType)

    let initBodySubscribe = quote(
        this.$identifierAssociated.subscribeEx(this)
    )
    return (initParam, initBodyAssign, initBodySubscribe)
}

func generatePropInit(varDecl: VarDecl, varExpand: VarDecl): MacroExpandInitInfo {
    let identifier = varDecl.identifier
    let valType = varExpand.getTypeByInitializer()

    let identifierAssociated = varExpand.identifier
    let initParam = quote($identifier!: $valType)

    let initBodyAssign = varInitAssign(identifier, varExpand, VarInitType.PropType)

    let initBodySubscribe = quote(
        this.$identifierAssociated.subscribeEx(this)
    )
    return (initParam, initBodyAssign, initBodySubscribe)
}

func getInitParamVarType(identifier: Token, varExpand: VarDecl): Tokens {
    let valTypeExpand = varExpand.getTypeByInitializer()
    return quote($identifier!: $valTypeExpand)
}

func generateLinkInit(varDecl: VarDecl, varExpand: VarDecl): MacroExpandInitInfo {
    let identifier = varDecl.identifier

    let identifierAssociated = varExpand.identifier

    let initParam = getInitParamVarType(identifier, varExpand)

    let initBodyAssign = quote(
        this.$identifierAssociated = $identifier
    )

    let initBodySubscribe = quote(
        this.$identifierAssociated.subscribeEx(this)
    )
    return (initParam, initBodyAssign, initBodySubscribe)
}

func generateProvideInit(varDecl: VarDecl, varExpand: VarDecl): MacroExpandInitInfo {
    let identifier = varDecl.identifier.value
    let provideIdentifier = match (stateManageHandler.provideVarDeclsMap.get(identifier)) {
        case Some(v) => v
        case _ => identifier
    }
    let identifierAssociated = varExpand.identifier

    let value = generateStateInit(varDecl, varExpand)
    let initParam = value[0]
    let initBodyAssign = value[1]
    let initBodySubscribe = value[2] + quote(
        this.addProvideVar($identifierAssociated, $provideIdentifier)
    )
    return (initParam, initBodyAssign, initBodySubscribe)
}

func addInitConsume(identifier: String, ty: Tokens): Tokens {
    var identTokenAssociated: Token = generateAssociatedToken(identifier)
    let consumeIdentifier = match (stateManageHandler.consumeVarDeclsMap.get(identifier)) {
        case Some(v) => v
        case _ => identifier
    }
    return quote(
        match (parent) {
            case Some(parentValue) =>
                this.$identTokenAssociated = match (parentValue.initializeConsume($consumeIdentifier) as $ty) {
                    case Some(v) => v
                    case _ => throw IllegalArgumentException("consume type should be same as provide type")
                }
            case _ =>
                throw IllegalArgumentException("consume should be used in the childComponent")
        }
    )
}

func generateConsumeInit(varDecl: VarDecl, varExpand: VarDecl): MacroExpandInitInfo {
    let identifier = varDecl.identifier
    let valTypeExpand = varExpand.getTypeByInitializer()
    let identifierAssociated = varExpand.identifier

    /*
     * add consume initialization in init function
     * @Consume var cnt: Int64
     * =>
     * match (parent) {
     *     case Some(parentValue) =>
     *         this.stateVarDecl_cnt_ = match (parentValue.initializeConsume("cnt") as ObservedProperty<Int64>) {
     *             case Some(v) => v
     *             case _ => throw IllegalArgumentException("consume type should be same as provide type")
     *         }
     *     case _ =>
     *         throw IllegalArgumentException("consume should be used in the childComponent")
     * }
     */
    var initBodyAssign = addInitConsume(identifier.value, quote($valTypeExpand))

    /*
     * add consume subscribe in init function
     * =>
     * this.stateVarDecl_cnt_.subscribeEx(this)
     */
    let initBodySubscribe = quote(
        this.$identifierAssociated.subscribeEx(this)
    )

    return (Tokens(), initBodyAssign, initBodySubscribe)
}
